# Why static pages
Recently I'm writing a website. The so-called SEO expert from our client demanded that all the pages must be static page for better SEO and fast loading speed. All though he is a completely idiot, I find that the static pages worked amazingly good! Now I want to talk about our implementation of the static pages.

# Static Url vs Static Pages
At first, I'd like to talk about the difference between static urls and static pages. Static urls have no query parameters so each url will be recognized as a page and processed by search engines. Whereas dynamic urls such as `http://domain/search?name=a&age=11` are not search engine friendly. Search engines will regard all such urls as one single url, namely `http://domain/search`. 

Static pages are pages in disks. When handling static pages, servers simply find the page and return it. Dynamic pages are generated by code, often invovles database access which means they are typically slower than static pages.

It seems that static pages are better since they are faster than dynamic pages. But it is not the case. In Web 2.0, content in pages changes so fast, every one may see different pages at different time. So traditional static pages are not sufficient. But avoiding dynamic generation is always good, so other techs emerge such as pagelet, page cache, etc.

# The architecture
Knowning the difference between static urls and pages, we can start to build our system. The system consits of 3 layers.

## Virtual Server Layer
The website is partioned to serveral modules. Each submodule uses a subdomain. We use Nginx to define virtual servers to handling requests to these subdomains.

+ resource.xxx.com: a virtual server serving static resources, including css/html/js/etc.
+ a.xxx.com: a virtual server for module A
+ b.xxx.com: a virtual server for module B

Requests to virtual servers are dispatched to our physical servers.

## Physical Server Layer
Our system has three kinds of physical servers. 

+ Static servers: serve static resources such as html, images, css, js, etc.
+ App servers: serve as an ajax endpoint and a page generator.
+ Admin servers: serve as an edit backend. Editor can add, modify, delete news and other information. 

## Storage Layer
Yeah, this layer is comprised of databases.

# How static pages are generated and served
Firstly I'll talk about what's our static server look like.

## Static servers
Static servers must allow us to upload static content and serve them to our clients. So how do we upload content? I've devised several solutions to this question. At first I want to use FTP, since it's a mature file transfer protocol and requires no more code. After a long journal and struggle, I found that FTP will use some unpreditable port to setup connections which is not acceptible since our servers can only have specified port mapped out.

After that I decided to use scp which works quite well in my daily work. But I found it somehow too slow(??? I'm not sure if I'm wrong). So I drop this idea quickly.

Finally I decided to write one myself. I implemented an upload service and a metric query service in spring-boot with embeded tomcat, which is fairly simple and efficient.

Each static server runs a simple program called `uploader`, when an editor adds an article, he requests the web server generator to generate the page and related pages which form a DAG. 

In addition, we provided editors with a management web ui. Editors can view status o static pages and their meta info such as last generated time. Editors can manually trigger new generation event.

## Serve static content
So we've already upload content to our static servers, how do we serve them? I simply employ Nginx to serve the content.

## Sync the static server cluster
Since we want to scale out our system, each component should be horizontally scalable. Then how to we scale out our static servers?

One can upload to an arbitary static server and the servers must be synced periodically. I decided to use Rsync. Note that NFS may also rock but it have drawbacks. Since multiple servers synced by rsync are fullly load balanced, they work better than NFS.

# Conclusion
Yeah, that's the whole story.
