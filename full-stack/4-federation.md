# 应用联邦
随着业务规模的扩大以及需求的多样化, 我们不可避免地添加新的功能. 添加新的功能最简单的方法是向已有的codebase中添加新的内容, 另一种是写新的应用, 部署在新的进程中. 传统的Unix程序员可能会倾向于使用添加新的应用, 这是因为他们有着良好的基础设施的支持(Pipe/Socket/...).

而在Web环境中, 我们通常没有这样的基础设施的支持, 因此, 我们倾向于将所有功能都写在一个应用中, 这甚至有一个专门的术语, 叫Monolith. 没错, Monolith是很好, 我们可以小心翼翼地向里面添加新的功能, 同时保证不会破坏已有的功能. 如果模块化做得好, 整个应用也不会显得过于杂乱难以维护.

然而, 有的时候问题并不是那么简单. 比如, 我们需要做一个实时行情的网站. 其中, 行情获取需要使用第三方应用的接口, 而此接口只允许一个IP访问. 而我们的主站应用注定要水平扩展, 因此, 将行情获取功能放在主站内是不合适的, 因此两者的扩展需求不同. 再比如, 获取到行情后, 我们需要进行k线计算, 而k线计算模块显然也不是可以水平扩展的, 因此它也得分离出来.

同时, 有一个接口除了主站要使用, 手机端也需要使用. 如果此接口放在主站中, 由于主站的线程资源是有限的, 如果主站的线程资源被其他模块占完了(比如主站有个直播模块, 需要维护长连接的. 同时主站会间隔性地生成静态页面, 会占用大量资源), 此时, 手机端也就不可用了. 换一个角度, 如果手机端流量过大, 则可以占用所有主站的线程, 此时, 主站可能就无法正常访问了.

当然, 类似的原因还可以列举很多. 因此, 很多时候, 我们不得不分离应用, 使用所谓的SOA或者Microservice架构. 它们解决了一定的问题, 但同时, 它们也引入了新的问题.

# 服务部署
考虑到我们本身只有一个Monolith, 假设我们有三台机子, 我们一台机子放一个实例, 前面加个LB. 部署问题就解决了. 但是后来, 我们引入了更多的应用, 且它们的部署需求还不一样, 有的需要水平扩展, 有的不允许水平扩展. 我们还需要考虑高可用, 如何部署它们? 假设我们有1000台机子, 5000个应用呢?

当联邦规模较小时, 我们完全可以手动部署, 但当规模大了呢?

在Infrastruture章节中, 我会专门说明这个问题.

# 服务联通
除了服务部署的问题, 我们还需要考虑如何联通这些应用. 比如, 应用A如何访问应用B. 直接用IP访问? 如果应用B有三个实例呢? 如果应用B的三个实例忽然挂了两个呢? 如果应用B的三个实例全部都挂了呢?

在解决上面的问题之前, 我们先考虑应用B. 如果应用B有三个实例, 我们如何实现对这三个实例的透明访问. 即, 实例只要还有一个可以访问, 整个应用就可以访问. 显然, 我们需要负载均衡器做帮助我们实现这一功能. 典型的, 我们可以通过两种方法来实现负载均衡, 将三个实例隐藏在应用B所定义的接口之后.

方法一是中心式/服务器端负载均衡, 我们使用一个中心负载均衡器(eg. nginx), 将其放置在三个实例之前, 从而实例透明访问. 这种方法需要额外的负载均衡器节点. 方法二是分布式/客户端负载均衡, 它需要和服务注册与服务注册一起使用. 应用B的所有实例启动时, 都会向服务发现中心注册自己. 应用A如果需要使用应用B, 会向服务发现中心请求所有应用B的实例, 并在客户端进行负载均衡. 这种方法需要额外的服务发现与注册节点.

一般的, 对于应用规模比较小的情况, 使用服务发现与注册可能是大材小用, 因此, 使用nginx的中心式负载均衡方案已经足够.

由于所有的应用实例都隐藏在一个负载均衡接口之后, 其他应用访问它时可以直接与负载均衡器沟通, 从而实现透明的访问.

# 消息框架
通常, 一个分布式系统需要很多基础设施, 如分布式配置, 服务注册与发现, 分布式缓存. 然而, 如果说, 分布式系统中最重要的基础设施, 我认为应该是分布式消息框架, 它可以说是分布式系统的骨架. 上一节提到的服务联通, 使用地是具名引用来访问一个服务, 然后, 既然使用了名字, 就注定了调用者与被调用者之间具有较强的耦合性. 而分布式消息框架则完成避免了这种耦合性. 消息生产者可以完全不用在意消息消费者是否故障, 数量有多少. 整个消息框架完美帮助我们处理了这一切. 消息框架之于分布式系统, 与Pipe之于Unix, 有异曲同工之妙. 实际上, 一个著名的消息框架Kafka就标榜自己为分布式系统的Pipe.

举个例子, 前面提供, 在写行情应用时, 我们有一个行情接收模块, 它负载接收实时行情. 开始时, 我们有一个k线计算模块需要使用此行情. 最初的设计是, 行情接收模块接收到实时行情后, 将其存入Redis, 然后k线计算模块来访问. 之后, 我们又引入了一个新的模块, 实时行情推送模块, 即, 我们使用从第三方获取的实时行情, 提供了我们自己的实时行情推送服务, 我们可以出售它, 让另外的用户通过tcp接入我们的服务, 此服务会不断地将最新的行情推送到接入的用户. 再后来, 我们又需要实现一个http行情服务, 它也需要实时行情. 如此, 我们需要在Redis中存储三份数据, 分别供三个应用来使用. 这显然是有问题的. 于是, 我们使用了消息框架取代了此设计. 行情获取模块在获取到实时行情后, 会将其发布到消息框架中, 其他模块只需要订阅它即可. 如果有新的需要实时行情的模块, 只需要简单订阅消息即可, 不需要再发动任何已有代码.

消息框架还有很多隐性的优点, 如:

+ 解耦/高可用：一个挂了，不影响其他组件
+ 异步/加快响应速度：Fire and forget!
+ 并行：消息是并行发送的，效率很高
+ 最终一致： 某个组件暂时挂了，不影响业务

That's all!

# 参考资料
+ [Microservices](http://martinfowler.com/articles/microservices.html)
+ [MonolithFirst](http://martinfowler.com/bliki/MonolithFirst.html)
+ [实施微服务，我们需要哪些基础框架？](http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service#rd)
+ [Open-Source Service Discovery](http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/)
+ [Docker Service Discovery Using Etcd and Haproxy](http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/)
+ [Apache Kafka, Samza, and the Unix Philosophy of Distributed Data](http://www.confluent.io/blog/apache-kafka-samza-and-the-Unix-philosophy-of-distributed-data)
+ [淘宝的消息中间件(2013)](https://segmentfault.com/a/1190000003059871)
+ [阿里分布式开放消息服务(ONS)原理与实践_沈询](http://v.youku.com/v_show/id_XODY5ODcxNjI0.html)
