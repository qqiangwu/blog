# 设计
C的设计相对于同期来说是局促的。C语言具有明显的历史局限性是不争的事实。 
类型系统是一个显著的例子。理论上，typed lambda calculus在当时（70年代）即便没有流行也已经有了数十年的发展，但是C的设计并没有有效利用当时的理论成果，还在前人的经验上开洞（比如奇葩的函数指针转换）。 
类似地，数组类型也不是第一类实体，也会有类型上的修正。 
这些无聊的设计除了让抽象变复杂，限制用户的自由外，唯一的好处也许就是顺应之前的具有局限性的语言实现的习惯了。不过，今非昔比，这样的设计并没有简化现在的语言实现——不管是C还是其它语言。 
这种仓促的设计影响深远。C++至今仍然把一些肇始于C的奇葩转换保留在“标准转换”中，以至于重载的规则加倍复杂——考虑到兼容问题以及维护规则本身的困难，这些无谓的复杂性今后可能永远也无法移除。 
左值(lvalue)是一个不幸的设计。一开始作为文法性质，并没有考虑到潜在的复杂，以至于后来引入const后，功能和区分左值在相当大范围内重复了（若完全一致反倒还好点）。这点另外有说过，按下不表。而这里重要的是，也无法指望丢弃冗余性（C++甚至变本加厉）。 
当然，考虑历史的主干，C来自于B，来自于BCPL，来自于CPL，来自于ALGOL 60，来自于ALGOL 58，来自于FORTRAN。这些语言都没有这方面的合理经验积累。所以C的设计的局限，并不难想象。 
也有一些其它的不足之处——丢弃有用的特性导致的倒退。不过，有些被纠正过来了，例如BCPL后扔掉的单行注释（//），被某些C方言、C++和C99以及其它一些C-like派生重新吸收。 
还有一些奇葩的莫名其妙的地方。B里面叫vector的东西说的好好的，怎么到C里面就变成array了呢？只是因为加了个残疾的“数组类型”？（B是没好意思说成有类型的……）为什么array而不是vector就非得能对元素“O(1)访问”——这种偏见是谁发明的？（另一个不良后果是A.Stepanov搞STL的时候没词了就顺手捡了个……）

# 标准化的有效性
不能否认，在被规范化的语言（而不是实现）针对平台的可移植性来讲，C差不多应该是现在的语言中最强的了。ISO C++在某些少数极端情况下的可移植性的确不如ISO C（见WG21/N4049）。而其它语言，假定1字节不等于8比特的大小就足够打退堂鼓，若不够可以再加上允许原码/反码作为有符号数表示——这两者是ISO C和ISO C++都明确支持而其它大部分语言规范都与之矛盾的东西。 
标准化的一个重要作用是取得共识，避免一些重复工作，提升可移植性，减轻用户（包括实现者）的负担。若标准被架空而没有被实际使用，标准本身就失去了绝大部分意义。 这里的一个反面素材是C#，.NET的实现都出到5.0了，ECMA-334到现在还是当年2的版本……（还有C#里把finalizer叫成destructor的奇葩导致混乱的说法在ECMA里被纠正了，MSDN上仍然将错就错。） 
啥，ECMA是区域性组织，不够权威？——人家现在叫ECMA International好不好。不过不够权威好像是能坐实点，C++/CLI在ISO标准化被英国的意见驳回，ECMA就通过成ECMA-372了…… 
那么这里就拿C++比较好了。同样是ISO/IEC JTC1/SC22下的工作组，两者的产出看似类似，效果大相径庭。 
而敢无视WG21的实现——据我所知，一个都没有。即便GNU早年隐晦地表达过和标准划清界限，现在来看在C++前端是口嫌体正直了。反观GNU C，这个效应就弱得多。 
简而言之，ISO C虽然整体上是有效的，但是对于语言实现者来说，效力略为不足。 
概括起来，这有两方面原因。 
其一是WG14本身的活动没有WG21强调“open”。WG21的文档早就被公开多年，而WG14的没记错的话到2012年才被公开。 
可能是由于C++本身的复杂性以及历史教训（轻率引入export和dynamic exception specification）需要避免消极的design by committee的影响，参与C++工作讨论的非委员会用户活动非常显著，Google Groups里讨论标准提议的论坛已经开设了好几年。isocpp.org也是一例。WG21甚至在github上拥有公开仓库允许用户pull request修改标准草案的内容。 反观C方面呢？一个对应的东西都没有。

作为工作产出来看，WG14公开的paper也要比WG21少得多（得多……） C++比起C真有复杂到这种程度么？还是说C的“社区”（暂且这么说）在传统上就“不够进取”？或者根本不愿意达成共识呢？ 第二点恐怕未必。POSIX就比较活跃了。 可笑的是，维护POSIX的Austin Group和WG14之间也能出现琐碎的意见分歧。参见WG14/N1174。

原因是其二——还是C的设计。 C欠缺了太多东西。 上面的隐晦分歧就是指，是不是在标准化的接口中，允许函数返回动态分配的对象然后让用户自行释放？ISO C的意见是“不”——于是asprintf乃至strdup都不可能出现在ISO C标准库，但这个原则之前看来从来没有被正式提起过。而POSIX方面以及其它传统C用户大概不会这么认为（特别是GNU）。 其它主流语言里还有这种奇葩问题么？ 而ISO C新引入的东西，很多也不是自身的设计。 ISO C11引入的sequenced before的wording，是WG21/N2239提出来的。注意，是C++的paper，C后来照搬过去了。 （嘛，C++比较激进删除了之前ISO C引进的sequence point，不过这里有个bug，漏了sequenced after这个定义，我邮件过去了，处理情况见github.com/cplusplus/draft/issues/61。） C11同时照搬过去的还有多线程和atomic的基本概念。由于语言特性上的先天不足，C没法做到C++的优雅（虽然这词普遍恶心，但用在这里的确不错）。（看看那个奇葩的Atomic……） C11还不得不引入了某种意义上的“临时对象”，这种手段又是埋坑。 C11绝无仅有的东西呢？哦，比如generic-selection？我问一下，这里谁对Generic有印象的？知道它是怎么回事的？能说清解决了什么问题，并且是怎么起作用的？有多少人在实际代码中用过？在其它语言中类似的东西是什么？ ISO C比ISO C++多出来的，特别是近来新添加的，差不多尽是广大C用户都难以认同的琐碎玩意儿…… WG14，请不要玩脱。

# 用户素质
本来我在这里不想攻击任何人。但是C的用户在辩护语言和实现表达自己的观点时，表现出来的槽点明显比其它语言的用户多得多，并且不少自以为得计，优越感爆棚。忍无可忍。 在这里起到负面影响的用户都可以概括成不同程度的“不懂装懂”“在不熟悉的领域里瞎BB”“误导”，不过可以分成那么几类（也有不少复合的）：

+ 原教旨主义 认为C是程序设计语言发展历史上的“正统”——却连老祖宗ALGOL的地位和影响都不知道，甚至和亲爹B语言之间的差别都一问三不知。
+ 盲信 不管可以引证的依据和理性思辨而盲目认同一些经不起推敲的观点（比如C比起其它高级语言总是“性能高”“开发效率低”）。
+ 无知 缺少其它语言的使用经验却臆测行为和实现。甚至对C自身的基本概念（比如“对象”“左值”“未定义行为”）都说不清楚。
+ 不独立思考 缺乏怀疑精神，对符合固有印象的说法来者不拒，却不考虑理由。“我听说”……“人家×××就是用C写的！”
+ 缺少专业基础 没有PLT常识，对其它语言品头论足，对其中和C设计不同之处——而不是不足之处做出非理性的批评。 从经验上来看，这些用户中最核心的部分同时是UNIX的脑残粉——包括一些只用过Linux然后把自己包装成UNIX粉的。 这些用户，绝大多数都说不清楚C（也许还有UNIX）历史和发展方向之类的详细问题，要提一些现有实现的缺陷和可改进之处都支支吾吾，甚至说不清楚为什么好用，满足了什么需求（某些果粉都比他们更强一点）。 脑残粉本身不足一提，不过当一些“知名人物”也具有这些特质之后，他们就好像找到了什么被撑腰的了——却不知道很多“大师”在评论这里的问题上很多也是半外行，跟普通用户无异。

# 增补1：
既然提到了有符号数问题，这里加列个草稿。虽然算不上C的问题，但不少C和C++用户都仍然对这个问题稀里糊涂以至于设计出渣接口。

对于C/C++以及其它大部分语言来说，不管是有符号数还是无符号数，首先指的都是刻意设计用硬件上具有特定表示的整数数据类型，即有存储空间大小和范围限制的、值的表示连续的定长整数。 
从类型系统的角度上来说，对于表示算术操作的类型而言，类型限定它有意义的取值范围，同时可用于决定它具有的操作。 这里的整数类型和数学中的整数显然不同——最显然地，它是有限集。但关于操作上的不同就经常被有意无意地忽略。大多数情况下这不是被期望的。 实用中，有符号数和无符号数的不同在于，无符号数具有确定的表示方式，且尽管在不同的体系结构上大小不一致，但都遵循2^n的模算术。注意和数学中的整数的一般算术操作的差异，例如模算术减法在不够减时结果会回绕(wrapped) ——比被减数更大。 而有符号数则没有这样普适的一致性：至少可以有原码、补码和反码表示。ISO C和ISO C++都规定：允许有符号数使用三种表示方式（之一）。占用空间相同的有符号数的表示不保证可移植性。同时，有符号数的操作导致超过表示范围（溢出）则行为未定义。而对于有符号数的一些转换和位操作是实现定义行为。 而与此相反，无符号数的性质要确定得多。在确定模算术的意义上可以推导出一些方便的性质，例如无符号数一定不会溢出。无符号数也不会有上述有符号数操作的实现定义行为导致的实现差异。 从实现角度上看，通常无符号数更容易被硬件高效地实现。只支持有符号数而不支持无符号数操作的实用体系结构似乎从来就不存在。 从抽象角度上看，无符号数的上限比同样大小的有符号数更大，所以在确定不需要符号时，更有利于正确的数值表示。 因为上述原因，sizeof的返回值`size_t`类型确定是无符号数类型。类似地，在C和C++中，除非必要，应当避免使用有符号数。 相对地，Java使用（范围被硬编码的）有符号数而放弃使用无符号数。这在一般意义上是一种错误的（类型系统）设计：损失功能且带来了更多的麻烦。 除了失去上述无符号数确定的性质（Java倒是确定了有符号数位操作的语义），这导致一些只需要无符号数的场合，同样的大小范围损失了近一半，并且导致程序更加不清晰：用户没有办法表示“我这里就只需要一个非负数”“你应该能预期结果是个非负数”（天杀的Java还没typedef和宏……）。 只有有符号数导致Java需要引入>>>操作符以便区别对待符号位，在另一方面导致了语言的复杂。缺少无符号数还导致一些应用上的麻烦——例如实现随机数生成器、通信协议或者图像处理算法之类。 Java抛弃有符号数的理由据信是“无符号数更复杂，因此不需要”——根据上面的分析，这是典型的扯蛋。一个比较可能的实际理由是对无符号数“莫名其妙”地回绕的无谓恐惧，特别是对结果比较操作上。但事实上，任何一个对这些语言中算术操作有清楚了解的用户，都不应该陷入这种陷阱，特别是编译器能轻易检查出对有符号数的不保证兼容性使用的情况下。 大概也正是因为如此，C#没有在这里“借鉴”Java，还是补充了uint。不过，C#的语言规则导致uint和int诊断消息设置有些神经质，大量用户代码中还是充斥着本来不应该出现的int。设计者应该只是确信uint不可少，但只是有符号数的补充，而非尽量鼓励使用的对象。这和C/C++的设计非常不同，也并没有完全发挥无符号数的好处。 于是话说回来，为什么在C/C++这样支持并且某种意义上更鼓励尽量使用有符号数的语言中，为什么还是有人非得喜欢int到底呢？ 恐怕原因和上面的一致。简而言之：这些人（包括某些抽风的语言设计者）自己就没把这种受限的定长整数算术操作搞明白，又欠缺谨慎、耐心和全盘考虑，可能还有些偏执。

# 增补2：
关于C/C++和汇编语言的关系。

+ C是C，C++是C++，汇编是汇编。 ISO C规定了允许asm关键字嵌入汇编代码作为扩展，但C并不依赖这项特性。 可能由于Bjarne Stroustrup等对阻止语言分裂的立场（如果需要另一个例子，可以参照对Embedded C++的观点），ISO C++没有ISO C那种“扩展”的概念，asm关键字直接是正式的语言组成部分。 C++的asm-definition的含义是实现定义的，但同样也并不见得里面就是汇编语言——例如，Cheerp使用asm内联JavaScript…… 不管是C还是C++，作为实例的不支持内联汇编的实现也不难找，例如用于amd64的VC++。 所以即便是C，指望和汇编互操作在语言层面上缺乏一般的可移植性。
+ 作为实现的汇编语言和对象语言（例如C或C++）的关系。 一个常见的误解是“C和汇编对应”。事实上这种保证根本不存在。对于其它高级语言也大抵如此。 尽管现实大多数C或C++的实现使用汇编作为中间表示，没有谁强制所有实现都遵循这一点。于是这里需要排除不使用汇编作为中间表示的语言。也就是说，要考虑这点，就不是讨论C或C++语言本身而是具体实现了。 需要肯定的是，对于某个实现来说，作为中间表示的汇编和C和C++的某些操作的语义接近，有一些现实意义，主要在于互操作性的清晰简便。
+ C和C++在这里的差异。 注意，对于使用C和C++的用户，上述需求都存在并可以实现。C和C++实现在此的主要差异在于，C++提供更高级的抽象，这些操作在C中往往没有对应，所以这部分在这里没有比较的意义。 从实现的复杂性来看，C和C++公共具有的一些操作往往比较能直观地被理解。C++的其余部分涉及到更多实现细节处理起来较为困难。如果使用这些操作，的确会导致一些现实问题，特别是C++实现的ABI往往比C实现的更混乱。 但是，在需要考虑这类需求的场合，使用什么操作是可控的。如果只使用C++和C中类似的特性，那么问题实际上差不多复杂。 差异只是用户对C和C++的实现（即便排除C++中实现起来看似不够直观的部分）理解有所不同而已。 也就是说，到底还是用户自己的原因。（不作死就不会死……） 至于运行时依赖问题导致C++比C在这里欠缺可用性，这是另外的话题。
+ 还要注意的是，上面这些到底只是“接近”，并不是所谓的普遍存在的“对应”。 这个问题细说起来可以展开很多…… 有一个目的上出发的根本观点：设计可维护的程序，依赖的应该是接口而不是接口的实现。依赖实现的hack只是妥协而不应作为可靠的常规手段。 对于能够使用这些接口解决的问题，不需要也不应当依赖它们的实现。 一般地，高级语言的规范自身通过描述程序的语义和/或行为，事实上给出了一套更高级普遍的接口。 ABI规范作为适用于二进制互操作的低层次的接口，相对来说提供的是语言规范的实现，以缩小适用范围为代价，补充语言规范中没有限定的一些细节。 C/C++这类本机实现的ABI一般可以分为体系结构和编译器相关的两部分。可惜某些实现不给出清晰的、友好的、公开的规范，拿黑箱让用户自己猜……活该谁倒霉呢。 没有足够能参照的ABI，所以需要互操作时，不得不通过观察生成的中间代码来预测实际可能的程序行为，这也不是不能理解。这种不保证可移植性的程序行为，语言规范更加管不着。 （这里中间代码说的就是汇编，其它类似的还有JVM bytecode、CLR IL之类的中间表示，不过传统上汇编占这种情况的绝大多数。） 但在二进制互操作以上的层次，仍然依赖上面的手段——无理由、无益地依赖实现——就有些匪夷所思了。 或许实际情况是，这些开发者根本就对这些原则性策略缺乏清醒的认识。 造成这种情况的理由可能就是在于方便依赖“和汇编对应”之类实现细节在作怪——至少表面上来看，只要“会”汇编，对生成代码有个大体的经验，很多时候就能弥补对不清楚接口导致无法预料程序行为的不足了。 这显然是类似“撞大运编程”的错误姿势。只是大部分这类用户甚至不会考虑体系结构之间的可移植性，所以这种错误认知也不容易起到负面影响。一旦有机会，坑的会是谁呢。 由于种种历史原因（比如说早期编译技术比较初级导致编译器一般不会进行复杂的变换优化），C的实现往往给人一种在接口规范之外也容易找到“对应”的印象。不过，现代的实现对此已经渐行渐远了。 就这点这当然不能怪C，那么。这种破事说到底也只能当作某些误导作祟导致某些用户技能树点错学岔了产生误会了。 此外，对于学习语言来说，这种错觉的危害一般更大。考虑到这里的问题，先学汇编再学C这种路线应当被慎重考虑，不推荐一般用户以免形成先入为主的观点。当然，这是另外一个问题了。
+ 附带的其它结论。 除了上面的需求导致的现象外，一个副产物是，C++的抽象让不善于使用正确姿势思考问题的新手望而却步了，其中不少可能就学看起来“底层”的C去了…… 对于C++来说，的确可以算teachability的耳光响亮。不过，在“底层”方面的逗比用户也因此更少了，也许也是好事。 （另一方面，“纯OOP”逗比用户被Java之流给架走了不少……不过剩下来也许还有两方面都特别逗的用户，那就不怎么样了wwwwwwwww……）