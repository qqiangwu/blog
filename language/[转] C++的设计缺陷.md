# 设计上烂得最广泛的毫无疑问是类型系统——包括很多本来该在类型系统内的东西。
+ 基本类型在C的基础上重写了一遍，有微妙的不同，但换汤不换药，缺点差不多一个没少。
+ 继承了C的低质量的转换：integer promotion/array-to-pointer conversion//function-to-pointer conversion。
+ 继承了C对数组和函数类型的差别待遇。
+ 添加了动态类型，却支持有限，实际上搞出了ABI的坑。
+ 添加了和C不一样的布局，却不提供足够的、明确的、可移植的支持，导致基础设施的失效（如offsetof）。
+ 添加了引用类型，想取代lvalueness（参见WG21最早公开的paper），后来却坑了。而且现在还越搞越复杂，搞出了多种引用类型和value category，依然不视为类型，并且语义和用例容易被误解，且很多时候难以避免冗余编码。
+ 添加了参数化多态，却对高阶参数化类型（模板模板参数）有莫名其妙的限制导致不可用。
+ 添加了实质上的参数化类型，却独立于名义上的类型系统之外。
+ 添加了类型推导，却不足够支持一般意义的类型推断（例如构造函数）。
+ 添加了实质上的重写系统却没有相应的类型系统支持（如模式匹配）。

# 一些深刻的设计失误是差不多所有Algol60直系后裔都存在的功能缺失：
+ 同像性。这导致语言中不得不对反射做出特别对待。偏偏C艹到现在还没有。
+ 底层高级流程抽象。具体点说，能代替J operator或者call/cc之类的东西。这导致诸如coroutine不能被可移植地高效实现。
+ 活动记录抽象。这导致典型实现及其用户过于依赖特定于体系结构的运行时栈。实际上还同时有栈溢出UB这种无解的设定。

# 一些本不适合内建的特性相关问题。内建特性在兼容性和扩展性上尤其容易出现问题，特别是存在不够显然的实现的时候。
+ 异常不得不被实现为内建的，某种意义上是缺乏上述两者的直接结果——这导致了另外的问题：例如ABI兼容性；再如WG21/N4049。
+ 面向对象支持——关键是面向对象本身就没有个相对统一的认识，内建导致之后扩充多分派等需要顾及的太多而最终放弃，远不如CLOS之类的库解决方案灵活；同样在一些方面导致和加重了ABI问题。

# 阶段相关。
某种意义上是缺乏同像性的副作用。实现阶段数量过多，且过于琐碎，导致细节难以处理，也难以提高实现质量。
+ 预处理被标准化，但是细节比较混乱，导致了很多演进上的问题（像#ifdef和#if defined的冗余）。
+ 缺少可用的模块系统。
+ 存在语言链接支持单缺乏语言嵌入（只有一个asm还不指望能用）。

# 至于文法/语法嘛……本来不想提的，不过因为逗到一定境界也顺便提一下好了。
+ 兼容C的渣声明符中缀语法。特别地，C++11引入trailing-return-type后也没法放弃旧的语法，并存的结果是增加复杂性。
+ 比C更多的文法歧义。最著名的坑应该就是函数声明优先于初始化对象了。另外还有几个类似的地方。
+ 因为基本源字符集的限制，使用大于(<)和小于(>)的尖括号(angle brackets)代替了数学上习惯的看起来更扁一点的括号(chevrons)“?”和“?”。这导致了极大的解析上的复杂性，同时还需要增设特例规则（记号>>和记号序列> >歧义）。
+ 少数C的语法的不规则延伸，如new。除了单独的消歧义规则的复杂性外，特异的语法规则导致用宏替换实现一些操作更困难。