## Name lookup
1. 将一个名字关联到一个声明。如果名字是一个函数，可能有多个函数，则其构成重载集。
2. 名字查找完成后，进行重载解析。
3. 重载解析完成后，进行访问权限的检查。

## 分类
1. 非限定名查找（包含表达式中名字查找，如重载的操作符）
2. ADL雾里看花
3. 限定名查找

## 非限定名查找
1. using directives会将当作其内容存在于所在名空间
2. 全局空间中的名字声明要需要在使用前面
3. 名空间中的名字声明需要出现在使用前面
3. 名空间中函数定义中出现的名字，由当前块向上找（先经过包含函数的名空间）
4. 类X或者其内置类，出现在声明中的名字（即非成员函数定义块中）, 声明需要在使用之前
    1. 出现在类X中，使用点之前的位置，或者，X的基类
    2. 如果X是内置类，还必须出现在X的包含类Y中，X声明之前的位置
    3. 如果X是局部类，需要出现在包含X的块中X的前面
    4. 如果X直接或者间接外于名空间中，则声明需要在使用之前之前
    5. 对于友元，只考虑包含X的名空间（非限定情况下）
5. 类X中成员函数定义块中或者非静态成员初始化列表中的名字，查找规则如下：
    1. 如果是在Block中，声明需要在使用前
    2. 查找X或者X基类或者X的外部类的成员（声明可以在使用后）
    3. 查找X所在的名空间或者父名空间，声明需要在使用前
6. 实现在类中的friend，使用类成员函数的规则；否则，使用名空间函数的规则
7. 对于A的friend member functions B::f：
    1. 参数列表先查B，再查A
    2. f的模板参数，直接查A
8. 对于A的static member的初始式，使用成员函数定义中名字的查找规则
9. 如果A中成员变量x定义在A外的C中，则x的初始化名字查找发生在C中
10. 函数catch中的名字使用包含此名字的函数的最外部块中名字的查找规则。特别的，catch中异常名不能与函数参数重复。

注意：模板定义中名字解析与此不同！
    
## 模板名字解析
1. 模板定义中可以使用的名字
    1. 模板本身及模板内的名字
    2. 依赖于模板参数的名字
    3. 模板中可见的作用域
2. 依赖于模板参数的名字除非以typename修饰，否则不会当作类型名。
3. `typename A::T x`中，T使用限定名查找规则，即使typename存在。于是，如果同时存在名为T的非类型，则报错。
4. 在特定情况下，`A::T`会被假定为类型，从而，不需要使用typename，如base type。
    
## ADL名字查找
略

## 几条结论
1. 如果使用了限定名，那么，依赖于参数的名字会进行本地查找
2. ADL只查找参数所在的名空间，而不查找其父名空间