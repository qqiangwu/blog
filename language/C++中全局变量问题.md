# Basic
## What the Standard say?
1. 同一编译单元中，对象按照其定义（不是声明，是定义）的顺序初始化。析构则相反。  
    + static初始化会发生在所有初始化之前(Link Time)。
    + dynamic初始化会按照其定义顺序进行初始化。
2. 编译单元内对象的初始化会在此编译单元内任意对象、函数被首次使用（可能在main的第一条语句之后）之前初始化。
    + 理论上全局对象的构造应该在main之前，但是具体实现可以将其推迟。

## What Effective C++ say?
1. 静态对象概念：存在于整个程序周期中。
    + 全局变量
    + 名空间变量
    + static member
    + function static(local static objects)
    + file-scope static
2. 非局部静态对象：上面除了function static的所有对象 
3. 静态对象的性质：
    + 在适当时刻初始化
    + 在离开main之后析构，顺序相反
4. 问题：如果一个非局部静态对象的构造涉及另外一个非局部静态对象，可能会出问题。因为那个对象可能还没有构造。因为，不同编译单元的非局部静态对象的构造顺序是未定义的！
5. 解决：
    + 可以用局部静态对象来代替，它的初始化是确定的，在函数第一次被执行的时候。这还有额外的好处，如果不使用这个函数，对象将不会被初始化。注意，在C++11中，这种方法是多线程安全的！   
    + 使用Singleton模式  
6. 关于用函数封装的static，声明为inline是一个好方法，标准规定此时static只能有一个副本！

## 其他
+ Nonlocal对象的初始化机制仅仅在main执行时才能被很好的执行，因此，用于其他非C++程序的C++代码应该避免Nonlocal对象。
+ 静态初始化的对象不存在上面的问题。
+ Local static的初始化是线程安全的，Nonlocal则非安全。

# 模块对象
## 对于静态对象C和C++的区别
+ C由于所有静态对象都是静态初始化的，所以不存在变量未构造的问题。
+ C++由于支持动态初始化，所以会出现上面所说的问题

## C标准库中模块的实现
C标准库中，大量使用了static变量（包括全局的和非全局的），当然，唯一可能是全局对象的只有errno，其他的都是实现定义的。我将其称作模块变量。在实现一个模块时，我们需要维护大量内部状态，此时，全局变量是不可少的。当然，我们应该尽量让其具有internal linkage，以隐藏实现。同时，对于这些模块变量，它还使用了Lazy初始化。

以前，我一心避免所有的全局变量，并用单例，因为它的问题很多。实际上，在C中它是没有问题的。在C++中，弄懂了static变量的初始化，应该也不再是问题。单例解决的只是初始化顺序不确定问题，所以，如果初始化顺序确定，那么，一切都没有必要。static变量某种程序上是不可避免的，最起码类static就是不能避免的。

## 模块对象的使用
实际上，弄懂了模块变量的性质，我们可以用它实现一些很强大的功能，比如：

```C++
namespace {
    struct Module {
        Module()
        {
            // setup the environment for functions in this module.
        }
        
        ~Moudle()
        {
            // cleanup the module
        }
    };
    
    Module module;
}   // module objects

// other modules members
```

## cin/cout问题
cin/cout可能在任何环境中被调用，比如，在某个非局部静态变量中，因此，我们必须保证它的初始化。一般的，这是通过`static std::ios::_Init init;`完成的。因为，一个编译单元中所有对象会在其中任意成员被使用前初始化。