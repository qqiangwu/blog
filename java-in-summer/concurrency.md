这是一个总结性质的文章, 并且主要以Java内存模型为基础.

# 为什么需要多线程(多线程的好处)
+ 物理上: 多核CPU的出现, 为了充分利用硬件, 我们需要更强的并行性
+ 逻辑上: 
	+ 串行模型建模简单, 编程简单. 其反面情况是, 为了处理更多的请求, 我们需要使用IO多工/异步IO等方式来编程, 其思维难度较大
	+ 某些程序本身需要并发的支持, 如字处理软件的自动保存功能, 如果将其实现为同步操作, 其响应性会很差
	
# 为什么需要避免多线程(多线程的坏处)
+ 安全性: 为了编写及测试在多线程环境下正确工作的代码, 程序员需要花费大量的时间与精力, 比起串行代码, 其思维难度大了许多
+ 活跃性: 除了考虑安全性(坏的事情不会发生), 我们还需要考虑活跃性(好的事情一定会发生). 比起串行代码, 我们还需要考虑死锁/饥饿等
+ 性能: 多线程不是免费的! 并不是用了多线程我们程序的性能就会高, 就会随着CPU数量的增加而免费增加. 线程的调度与同步都需要很大的开销

# 如何进行多线程编程
在了解了多线程的好处与坏处之后, 我们发现, 很多情况下, 多线程是无法避免的, 因此, 我们需要一个系统的方法来指导我们进行多线程编程, 使得我们可以充分发挥多线程的优势, 同时又可以避免它的种种问题.

显然, 无论什么情况下, 把事情做对最重要, 然后才是做快, 做好. 于是, 我们首先来处理, 如何保证你的多线程程序是安全的! 在了解了如何写出安全的多线程程序后, 下面的问题很自然的就是, 如何处理数据与算法, 毕竟, 这是我们程序的两端. 我们需要使用线程安全的数据结构, 同时, 我们要能够将我们所要处理的问题分解/建模成一个可以使用并行方式来解决的模型.

## 保证线程安全性
想要保证线程安全性, 首先需要多线程情况下为什么会不安全. 显然, 这是因为, **多个线程会共享数据**, 这就引入了潜在的问题. 这里, 先定义两个名词:

+ Race Condition: 当多个线程同时访问一个对象, 且其中至少一个为写
+ Data Race: 未经同步的Race Condition, 会造成Data Race, 出现Data Race的Java代码, 其结果是未定义的

显然, 我们需要避免Data Race. 根据其定义, 我们可以在三种方法来解决这个问题. 然而, 在解决这个问题之前, 我们先来介绍Java的内存模型. 什么是内存模型? 简单而言, 就是多个线程访问内存时的行为, 如, 线程A/B同时执行x++, 其结果是怎么样的? 线程A写变量x, 之后线程B去读变量x, 其结果是怎么样的? 这其中涉及到两个问题: 有序性以及可见性.

理想情况下, 我们希望线程A/B的x++是有序的, 但是由于x++不是一个原子操作, 因为两者会重叠, 从而出现问题. 同时, 我们希望每个线程都可以读到变量x最新的值, 不论这个值是谁写入的. 但是, 由于内存比CPU慢100倍, 这种强同步的开销太大! 因此, 我们常常会做一定的妥协. 不同的硬件所做的妥协有不同, 而JVM屏蔽了这些细节, 为程序员提供了一个单一的内存模型. 说明如下:

+ 所以线程共享一个主存
+ 每个线程有自己的私有缓存, 所以数据会先从主存中读取到私有缓存中, 然后进行操作

上面这两点的直接后果是, 线程A更新了变量x后, 线程B可能永远看不到. 线程AB可能同时更新了自己私有的变量x, 那么主存中的x最后会是什么?

为了保证线程A在其私有缓存更新了x后, B能够看到, 我们需要进行 **同步**, 简单地可以理解为将线程A的私有变量的值同步到线程B中, 实际上是A先将x写回主存, B再从主存中读取x, 更新自己过时的私有缓存；为了保证线程AB在执行一个非原子操作时, 两者不会重叠, 即有序, 我们需要 **同步**. 我会在之后的说明中, 介绍如何进行同步.

### 同步多个线程对某个变量的访问
根据Race Condition的定义, 我们可以通过某种协调机制, 来保证多个线程在访问同一个对象是, 会通过某种顺序来访问, 而不是并行地访问. 这种机制我们称之为同步.



### 不在多线程间共享变量
这个思想很简单, 但是是解决问题的最好方法. 它还可以细分为三个维度, 我将从最简单到最复杂的顺序来介绍它们

+ stack变量: 将所有的变量在线程栈上分配, 栈是局部于线程的, 因此, 不会有其他线程来访问它
+ thread-local变量: 比起stack变量, thread-local变量稍微复杂了一些, 但是它可以避免线程间共享数据. 同时, 它又是一种不太好的设计, 因为它在某种意义上是一个"全局"变量. 考虑这样一个例子, 我们有一个线程安全的StringFormat对象, 在format字符串时, 它依赖一个内部Buffer, 显然, 在调用format方法时, Buffer不是一个stack变量, 它会在多线程间共享, 为了保证线程安全性, 我们需要同步所有调用, 即加锁. 然而同步是需要开销的, 我们希望避免它, 因此, 我们可以将Buffer声明为ThreadLocal, 如此, 每个线程会有自己的Buffer, 而互不影响.
+ 人工保证不在多线程间共享变量: 这是一种最为反人类的实现方式, 就是人工保证某个变量只会在特定线程中被访问. 典型实现是GUI系统, 如QT, 所有控件都只会在主线程中被访问

### 使用不可变对象
