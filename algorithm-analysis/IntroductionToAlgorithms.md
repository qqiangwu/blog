为了更好的掌握算法，对算法进行分类是有帮助的。然而，标准不同，算法的分类也不同。如：

1. 按照目的分类：如sorting。这样分类，让我们可以清楚地知道，解决一个问题时，应该使用或者说需要什么算法。它更多的是从使用的角度来说的，对于实现，没有太大帮助。
2. 按照实现分类：
    + Recursive or iterative: 最基本的编程手段
    + Serial or parallel
    + Deterministic or non-deterministic
3. 按照复杂度分类：实现用处也不大
4. 按照设计零规式分类：按照算法设计时使用的思想或者所遵循的规式来分类，可以为实现者提供实现算法的思路，甚至流程框架。一些规式常用于解决特定领域的问题。这是我所需要的，它让我的解决问题时，只需要判断问题的大概领域，然后，遵循一定的规则，即可搜索出可能的算法实现。

# 设计规式
实际上，并没有什么通用的设计规式，不同的人会有不同的看法。下面是我个人的总结，这些总结使得我在遇到新的问题时，可以通过简单分析其所属领域，来尝试使用特定规式来解决它。

### 增量式方法
简单来说，我们可以将其看作归纳法的逆过程。

1. 一般方法：假设一个小规模的问题已经解决，那么，对于在此基础上，解决一个大一些问题。
2. 基本编程方式：迭代
3. 示例：插入排序

### 归纳法
这是最基本的基于递归的设计方法。可以看其看作单路分治。

1. 一般方法：将大问题化归为小问题
2. 基本编程方式：递归
3. 示例：选择排序

通过，归纳法可以实现为尾递归

### 分治法
用于将一个大问题化归为多个不重复子问题的情况

1. 基本编程方式：递归
2. 示例：快排

### 动态规划
动态规划一般用于用空间换时间的算法当中。它也是递归算法的一个分类。一般的，当问题具有以下特点时，可以使用动态规划：

1. 最优子结构
2. 子问题重叠

理论如下：

1. 适用于：最优化问题
2. 基本编程方式：
    + 递归 + memento
    + 迭代 + 表
3. 示例：Fabonacci

### 贪心算法
贪心算法也用于求解最优化问题，动态规划需要比较多个子结果的结果，做一个选择，从而选出最优结果。而贪心算法则直接选出局部最优结果，从而避免了重回复杂的计算。

1. 基本程序方式：迭代或者递归
2. 示例：DFS、BFS、Dijstra最短路径

### 线性规划
暂略

### 归约 Transform and Conquer
如其名

### 随机算法
在算法中引入随机变量，从而使得算法的期望时间可以进行分析。

概念：  
1. 放宽对正确性的要求，获得概率上正确性比较高的解。通常，可以多次运行，以提高正确率
2. 在算法过程中引入随机化，提高算法的期望性能

分类:  

1. Los Vegas: 总是能给出正确的解，但有时无法给出解
2. Monte Carlo：总能给出解，但不一定正确

实例：  
 
1. 随机化快排：使得最坏情况的出现与输入无关，仅由随机选择决定
2. String-equality：随机化除数p，多次选择p以降低假匹配概率
3. 模式匹配：Monte Carlo方法，取指纹
4. 随机取样：n取m
5. 素数性测试

### 近似算法
暂略

### 数据结构建模
这个分类的具体思想比较多。简单来说，就是将问题建模为一个标准数据结构，从而，可以使用数据结果的操作来对问题进行解答。比如，回溯法将解空间建模为一个树，从而，寻找解，变成了搜索树结构。

我们用得比较多的是搜索方法，即，在解问题中搜索最优解。

示例：  

1. 库依赖问题的Graph建模
2. 通用搜索方法