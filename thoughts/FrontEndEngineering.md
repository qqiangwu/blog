# 起因
大约是2016年1月23号, 我听到了前端工程化这个名词. 这让我有些惶恐, 因为我根本不知道这是什么, 这种无知会让我很有失败感. 之后, 我花了大约三天时间, 约略了解了这个名词背后的故事.

# 前端工程化
与其叫做前端工程化, 我觉得, 叫做前端自动化可能更加容易理解一些. 从名字看来, 这一个一个关于前端的东西. 那么, 为什么会有这么一个东西呢?

### 故事1
首先, 一个常识是, 前端需要优化, 比如, 将CSS放在头部, 将JS放到尾部, 合并文件, 压缩文件. 然后, 与之相对的是, 开发时, 最少我们不会合并文件及压缩文件, 否则调试将是一件很痛苦的事情. 这告诉我们, 用户看到的页面与开发者看到的页面是不一样的, 我们需要一个过程将它们联系起来. 于是, 引入 __构建__ 过程成为一个非常直观的选择. 稍微做过一些node开发的人, 肯定会知道gulp/grunt这些构建工具, 用于通过一些任务来对资源文件进行优化.

### 故事2
做为一个程序员, 模块化开发应该是最基本的素质. 因为模块化让功能项目更容易管理, 当然, 有些模块化也能带来复用的效果. 然而, 在前端开发这个领域, 似乎模块化这个概念并不那么盛行. 当然, JS的模块化已经有很多人在做了, 比如bower, npm. 页面组件的模块化可能更加那不那么乐观了. 当然, 本质上, 大部分前端团队是缺少模块化的, 看看他们的项目目录结构就知道了:  

+ js/
+ css/
+ images/
+ pages/
+ index.html

缺少模块化, 使得开发难度剧增, 不同种类文件的分离, 使得最后我们自己都不知道哪些东西在用, 哪些东西不在用了.

事实是, 模块化/组件化依然是一个很复杂的命题. 每个团队都会有自己的技术造型. 但最少, 所有模块化都需要 __依赖管理__. 假设我们已经有了模块化手段, 那么, 在写新的功能时, 我们只需要引入已有的模块. 假设我们有一个SearchBox的组件, 当需要在一个新的地方使用时, 我们希望写出以下的内容:
```
<body>
    <SearchBox/>

    <!-- or -->
    <link type="import" src="modules/searchbox"/>
</body>
```

然后, SearchBox依赖的那些css, 那些js, 我们是否需要手动地将其加到页面头部/尾部? 显示, 我们需要自动化的工具.

### 所以呢?
不论是优化问题还是模块化问题, 页面真正运行在浏览器中与程序在开发它们时, 都是不一样的. 我们需要一个 __构建过程__ 来将源代码转化成目标代码. 想一想, 这个构建过程需要做些什么?

+ 单文件处理: 翻译(比如scss)/压缩/加md5后缀
+ 打包处理: 打包js/css, 图片雪碧图
+ 资源引用管理: 当我们给文件加了md5后缀, 进行了打包, 我们需要更改其所有引用
+ 依赖管理: 引用一个模块时, 我们希望自动将所有其依赖的js/css/tpl全部引入
+ 资源注入: 内联css, 注入组件模块代码
+ ...

这些过程让我想起来了编译器. 现在大部分程序语言都有依赖管理/代码优化这些特性, 如果将前端资源也看成是一门编程语言, 我们显示也需要对其进行编译, 得到 **可执行** 的结果. 编译的核心是 ***符号表***, 有了它, 我们可以追踪所有引用, 可以内联代码, 可以动态加载/按需加载, 可以将多个模块联结起来. 与这些比起来, 对代码进行预处理反而是小case了.

于是, 我们可以将编译的结果看作是可执行文件, 即最终的html/js/css什么的. 当这些可执行文件加载入浏览器时, 已经是最优化的了. 当然, 为了支持动态加载/按需加载什么的, 还需要一个加载框架, 想一想, 即使是exe执行时, 也会加载一些动态库文件的吗(全静态链接的当我没说)?

当然, 有时编译后得到的还不是"可执行文件", 因为它可能会被某种后端所服务, 因此之能算中间码. 然而, 这些都不重要了, 有了符号表, 多个工程都变得简单了许多.

### 最后
上面说的这个编译的过程, 是实现前端工程化/自动化最主要的手段, Facebook管这叫静态资源管理. 不过, 既然是 **工程化**, 是不是还有些更加复杂的东西呢? 可惜地是, 以我的经验, 还无法理解更多, 虽然网站资源很多. 总之, 对我这个非专业前端程序员来说, 在前端开发中引入模块化/编译, 大约就已经能够开发出一个比较不错的页面了. 至于更加复杂的工作, 也应该由更加专业的人来做.

从大局上来讲, **高效开发** 与 **高性能页面** 是我们的追求, 引入编译过程, 是解决这对矛盾的不二法门!

参考资源:

+ [一个前端牛人的Blog](https://github.com/fouber/blog)
+ [Facebook静态资源管理](http://velocity.oreilly.com.cn/2010/index.php?func=session&name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96)

# 模块化与组件化
嗯, 之后我就不区分这两个词了, 总之都是KISS思想的产物.

### JS的组件化
JS组件化做得算是不错了, 比较出名的组件库有bower与npm. 然而, 既然是组件化, 我们希望能有下面这些东西:

+ 依赖管理
+ 按需加载

于是, 我们需要模块规范以及可以执行这个规范的执行器(模块加载器). 现在有很多标准, 比如amd/cmd/commonjs/umd. 个人比较倾向于commonjs, 因为, 它有npm这有一样已有的巨大组件库, 如果我们可以直观使用它, 那真是极好的! browserify已经实现了npm组件的复用. 至于bower, 虽然号称是个组件库, 但是, 主要组件的规范还停留在直接将模块引入全局空间的层面. 以至于依赖管理只能通过配置文件完成, 按需加载就复杂一些了. 没错, 我们是可以通过配置完成完成bower组件的依赖管理与按需加载, 但这样要做的工作就有些太多了. 而使用npm, 我们可以通过`require`分析依赖, 我们有`exports`, 从而按需加载的时候可以知道加载进来的是什么东西. 用bower的话, 鬼知道它在全局空间里面放了什么...

嗯, 我实现了两个fis3的插件, 可以集成bower及npm的组件:

+ [fis3-hook-bower](https://www.npmjs.com/package/fis3-hook-bower)
+ [fis3-hook-npm](https://www.npmjs.com/package/fis3-hook-npm)

### 页面的组件化
相比JS的组件化, 页面的组件化就复杂许多了! 然后它偏偏又那么重要! 听说过WebComponent, 但这种标准性质的东西正式落地还需要很多年.

组件化很多时间取决于所有的具体页面技术, 比如现在比较火的AngularJS/EmberJS/ReactJS这些框架. 它们都有某种可以复用页面内容的方式. 说说我了解的两个框架AngularJS/ReactJS. ReactJS是一个很纯粹的View框架, 号称是面向Component编程. 正是由于它比较纯粹, 因此, 灵活性更高. 而AngularJS, 1.x版本赞誉与争议并存, 问题太多, 以致于2.x版本完全重写了... 就其页面组件化的努力来看, Directives还是挺有可取之处, 最少开发效果还是蛮高的(虽然写起来太复杂). 不过AngularJS的模块机制太坑, 以至于写大型应用让人有些不放心.

当然, 页面组件化的问题远远比我们想象的复杂得多. 所以对我来说, 简单的复用就已经很好了, 主要还是分离开发.

估计在我的下一个项目中, 会尝试ReactJS来做为View层, 并实现页面组件化.

# 前端框架
只所以会考虑前端框架的问题, 是因为考虑下一个项目的技术造型. 然而, 在这样一个前端战国时代, 选择这个真心不容易.

要说明的是, 新提出的这些技术, 比如React/Flux/Redux/Immutable/MVVM, 它们都是直接给出了一个解决方法, 这是研究团队在对所遇到的问题进行很长时间的研究后得出来的东西. 而对于我们这些没有碰到过这些问题的人, 就很难理解它们为什么要这么做, 它们又好在哪里. 相比较而言, MVVM就比较粗暴了, 有点前端经验的人都会知道手动操作DOM的痛苦!

先来说一些我所了解的几个技术:

+ Flux/Reflux: 两者的本质是单身数据流. 嗯, 这还是太抽象了一些, 其实就是UnixPipe/DataHub这些概念的应用. Component会触发Action, Action会trigger Model的更新, Model的更新会trigger Component的更新. 其实还是消息系统那一套东西. 单向的数据流使得程序的状态更加容易推导. 同时, 与所有消息系统相同, 它的可扩展性很强. 比如多个Component可以监听同一个Model的更新, 然后绘制自身. 比起双向绑定... 数据流更加清晰, 大约是这样吧. 果然还是没吃过亏...
+ React: 纯粹的View技术, 虚拟DOM效率很高, 还支持后端渲染. 听起来很好. 不过我更加关注地是, 它在页面组件化中能发挥多大的能力.
+ AngularJS: 开发效率很高的框架. 但是坑也不少. 目前我最无法接受的是, 它对按需加载/异步加载的不友好以及有些恶心的module. 中心化的路由方案也让分工变得有些麻烦.
+ 其他MVVM框架: 有AngularJS专美于前, 其他的我也不怎么想去研究了, 比较生态系统也一样重要, 我还是倾向于从AngularJS与ReactJS中进行选择.

嗯, 所以一个比较倾向的技术造型是React作为View, Reflux作为架构层, 至于路由方案, 还是要研究一翻.

# 反思
花了这么长时间, 看了一堆资料, 只是由于初见前端工程化时自己心中的惶恐. 不过, 现在看来, 还是太年轻!

反思了一下.

### 作为一个程序员
基础的编程素养的具备

+ 要有模块化编程能力
+ 知道如何组合模块
    + 非自动化: 消息总线/显示引用
    + 自动化工具

### 作为一个架构师
+ 要有对未来的把握能力: 知道技术的前景是怎么样的, 保证自己的团队不会走错路
+ 要有对全局的把握能力: 知道整个场景应该是怎样工作的, 知道端内技术的真正实质, 不追逐边角
+ 要有`逢山开路，遇水搭桥`的能力: 拥有分析问题与解决问题的能力, 在把握未来与把握全局的前提下, 找到正确的解决方式.

总结来说, 要有`基本素养`与`天才的想象力与创造力`.

### 关于开发
+ 用技术不断提高工程师的幸福感
    + 为什么不幸福?
        + 所用的框架不复杂? 修改它!
        + 工作的流程太复杂? 自动化!
+ 发现痛点、分析调研、应用改进

### 关于技术
+ 技术是要积累的, 现在很多东西脑子里没有一个清晰的印象不重要, 关键要知道什么场景下需要什么, 要有自己分析的能力
+ 大道至简, 不要被乱七八糟的技术迷了眼! 要知道, 用JSP也能干翻React(考虑开发效率与运行效率)!

总之, 不要纠结技术, 就像不要纠结语言一样! Kid!
